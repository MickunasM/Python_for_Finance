#%%
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 
import statsmodels.api as sm

'''
Consider the dataset in the file “portfolios.csv”. This dataset has 103 columns 
of data:
•	Column 1 has the date

•	Columns 2 to 101 have historical returns on the 100 stock portfolios. 
These portfolios were constructed by following the double sorting strategy on 
both size and operating profitability. Size is market equity (as usual) and 
operating profitability is a ratio with annual revenues minus cost of goods 
sold, interest expense, and selling, general, and administrative expenses on 
the numerator, and book equity on the denominator.

•	Column 102 has historical return on the risk-free rate, Rf
•	Column 103 has historical return on the market portfolio, Rm

NOTE: TO AVOID CONFUSION BELOW, WE WILL REFER TO THE 100 STOCK PORTFOLIOS AS 
100 ASSETS.
'''

# Load data
data = pd.read_csv("portfolios.csv", dtype = {0:str}, index_col = 0) 
bm = pd.read_csv("bookToMarket.csv", dtype = {0:str}, index_col = 0) 

'''
-   Print the number of rows and columns of data and bm.
'''

print(data.shape) # 696 x 102
print(bm.shape) # 696 x 100

'''
-	Extract 100 assets and assign them to a variable called assets. 
    Use .copy() command to obtain a COPY and not a VIEW on the df slice.
-	Store number of rows and columns of assets into variables rr and cc.
'''

# Extract 100 assets 
assets = data.loc[:, 'Asset1':'Asset100'].copy() # 696 x 100

# Obtain rr- number of observations, cc- number of columns (100 assets)
rr, cc = assets.shape


#%% (a) ----------------------------------------------------------------------:
'''
For each month in the data, sort the returns on the 100 assets based on the 
book-to-market ratio of those assets. (Ascending order). 
See L7_Code.py to help get started.

To answer this qn you will need to use “bookToMarket.csv” dataset which has:
  •	Column 1: date
  •	Columns 2 to 101: book-to-market ratio for eachof the 100 assets
'''
# Sort assets based on book-to-market in ascending order ---------------------:
assets_sorted = pd.DataFrame(np.nan, index = assets.index, columns =['N/A']*cc)

# Sort book-to-market 1 row at a time and obtain indices 
for ii in range(rr): # seq is 0 to 695, we are looping over rows
    # Obtain indicies by which to sort assets (ascending order, smallest first)
    inds = bm.iloc[ii, :].argsort() # inds is a pandas Series
    # sort assets based on indices inds of BM row ii
    assets_sorted.iloc[ii, :] = assets.iloc[ii, inds].values 
    # values will convert dataframe to numpy array

assets_sorted.iloc[0:3, 0:3]
'''
            N/A     N/A     N/A
196401  2.5834  3.4218  1.2349
196402  2.0490  2.0159  7.6875
196403  2.2237  1.7364  0.1374
'''
# Remember that assets are sorted based on book-to-market, so assets_sorted  
# entries themselves will not be in sorted numerical order.


#%% (b) ----------------------------------------------------------------------:
'''
Using the previous sort, group the 100 original assets into 5 new portfolios of 
equal-size. So the 1st portfolio has the 20% original assets with the lowest 
book-to-market ratio, the 2nd portfolio has the next lowest 20%, and so on. 

Compute the equal-weighted return on each of those 5 portfolios: so the average 
return across all assets in the portfolio.

Programming tips:
    
-	Create the results dataframe called portfolio, into which you will store 
    results. It should have the same index as assets and columns should be new 
    labels, for eg: labels = ['Portf1', 'Portf2', 'Portf3', 'Portf4', 'Portf5']

-	Loop over indices [0, 20, 40, 60, 80] (either generated by range, or stored 
    in a list) and extract 20 columns of sorted assets at a time. 
    Hint: ii:ii+n where n = 20 extracts a slice of n cols for all observations. 

-	For each such slice obtain the mean across rows and store the results as 
    portfolio column. 
    Hint: portfolio dataframe has 5 columns and will need to use a count variable which will 
    reference the column you will store results in. 
    Upon each iteration count is to be incremented by 1.

Report the mean and standard dev of the returns for each of these 5 portfolios.

'''
# Split data into 5 portfolios and find average for each t
labels = ['Portf1', 'Portf2', 'Portf3', 'Portf4', 'Portf5']
portfolios = pd.DataFrame(np.nan, index =assets.index, columns =labels) # 696x5

# ADVANCED: slicing dataframe beyond end works, but indexing does not
#assets.iloc[0, 80:111] # [allowed] even though dataframe only has 100 elements
#assets.iloc[0, 111] # [not allowed] 'index 111 is out of bounds for axis 0 with size 100'

n = 20
count = 0
for ii in range(0, cc, n): # range will produce this seq: [0, 20, 40, 60, 80]
# mean along each row, in a vectorised way for all rows in batches of 20 cols
    portfolios.iloc[:, count] = assets_sorted.iloc[:, ii:ii+n].mean(axis = 1)
    count += 1

portfolios.iloc[0:3, :] 
'''
          Portf1    Portf2    Portf3    Portf4    Portf5                                             
196401  1.585850  2.179685  2.460950  2.120025  2.870085
196402  2.143375  1.796885  1.556505  1.276995  2.747945
196403  1.760730  1.837280  2.862050  3.102900  4.593885
'''

mu = portfolios.mean(axis = 0)
'''
Portf1    0.957578
Portf2    0.941658
Portf3    0.906166
Portf4    1.026580
Portf5    1.133252
'''

sigma = portfolios.std(axis = 0)
'''
Portf1    5.324403
Portf2    5.207845
Portf3    5.145913
Portf4    5.354278
Portf5    5.461770
'''


# Let's view portfolios as subplots
portfolios.plot(subplots = True, figsize = (6, 10))
plt.show()

# Let's view portfolios on the same plot
plt.figure(figsize = (10, 8))
plt.plot(portfolios)
plt.legend(labels)
plt.show()


#%% (c) ----------------------------------------------------------------------:
'''
Compute the alpha and the beta of each of the five portfolios in b) relative to 
the market (i.e. perform CAPM regression on each portfolio time series). 

Programming tips:
-	Loop over 5 columns of the portfolios dataframe and obtain a regression at 
    each stage using the usual sm.OLS(y, X, missing = ’drop’) function. 
    Remember to include a const in the regression using X = sm.add_constant(x).

-	Append results into the lists given below, for alpha and beta, by 
    extracting corresponding values with results.params.iloc[]

-	Append the results for p-value by extracting them using 
    results.pvalues.iloc[]

If you print the results for alpha, beta and p-value at each iteration, you should obtain:
'''
# CAPM regression for each portfolio
rf = data['Rf'] # risk free
rm = data['Rm'] # market total return

alphas  = [] # store alpha
betas   = [] # store beta
p_alphas = [] # store p-value for alpha

x = rm - rf # Market excess return 

for ii in range(5):
    X = sm.add_constant(x)           # Add intercept term 
    y  = portfolios.iloc[:, ii] - rf # Excess return on asset
    model = sm.OLS(y, X, missing = 'drop')
    results = model.fit()
    # obtain estimated coefficients
    alphas.append(results.params.iloc[0]) # extract beta_0 (a.k.a. alpha)
    betas.append(results.params.iloc[1])  # extract beta_1 
    # extract p-value for beta
    p_alphas.append(round(results.pvalues.iloc[0], 4)) 
    # print out results
    print('Alpha', round(alphas[ii], 4), 'Beta', 
          round(betas[ii], 4), 'p-val', p_alphas[ii])

'''
Alpha -0.0502 Beta 1.152  p-val 0.3856 (low value stocks, go short portf 1)
Alpha -0.0492 Beta 1.1197 p-val 0.4164
Alpha -0.0688 Beta 1.0895 p-val 0.3113
Alpha  0.0446 Beta 1.1029 p-val 0.5938
Alpha  0.1542 Beta 1.0973 p-val 0.1053 (go long portfolio 5)
''' 


#%% (d) ----------------------------------------------------------------------:
'''
Compute the return on a factor-mimicking portfolio for Value by going long the 
portfolio with the highest book-to-market (portfolio 5 from part b) ) and going 
short the portfolio with the lowest book-to-market ratio (portf 1 from part b)). 

Programming hints:
-	Create a new variable called r_value which is simply an element-wise 
    difference between the last and the first portfolio [single line solution].
-	Plot a figure to display the returns of r_value 
'''

# Factor mimicking porfolio for value 
r_value = portfolios.iloc[:, 4] - portfolios.iloc[:, 0]

plt.figure(figsize = (10, 8))
plt.plot(r_value)
plt.legend(['Returns of Factor-Mimicking Portfolio'])
plt.show()

'''
Next compute some summary statistics:
    - mean of the series over the full r_value sample
    - mean of series since Jan 2008
    - mean of the series since Jan 2018
'''

r_value.mean()                # 0.17567330459770128
r_value.loc["200801":].mean() # 0.02985297619047619
r_value.loc["201801":].mean() # -0.1217371875

'''
Lastly, obtain the date at which the minimum in the r_value series occurs. 
'''
np.min(r_value)               # -8.599665
min_pos = np.argmin(r_value)  # index at which min value occurs
r_value.index[min_pos]        # '200003' date at which min occurs


#%% (e) ----------------------------------------------------------------------:
'''
Compute the mean, standard deviation and skewness of the factor-mimicking 
portfolio obtained in d). Repeat the same calculation for the market return, 
    and the excess market return (market return – risk-free rate).

Programming hints:
-	Use pandas methods mean(), std(), skew()
'''
# Stats of factor mimicking portfolio
mean_value      = r_value.mean()  # 0.17567330459770128
std_value       = r_value.std()   # 2.228794079971765
skewness_value  = r_value.skew()  # 0.5315352370694229

# Stats for market return
mean_market     = rm.mean()       #  0.9279711646005747
std_market      = rm.std()        #  4.431139100119897
skewness_market = rm.skew()       # -0.5384227698279539

# Stats for excess market return
mean_excess_market     = x.mean() #  0.5254218829913792
std_excess_market      = x.std()  #  4.4469317018762
skewness_excess_market = x.skew() # -0.5677788263012743


#%% (f) ----------------------------------------------------------------------:
'''
Compute the alpha and beta of the factor-mimicking portfolio with respect to the 
market excess return. Find the p-value for alpha.

Programming hints:
-	Run regression using y = r_value
    Remember to include a constant in the regression.
'''
# Regression of factor-mimicking portfolio wrt market excess return
X = sm.add_constant(x) # Add intercept to x (x was calculated as rm - rf)
y       = r_value 
model   = sm.OLS(y, X, missing = 'drop')
results = model.fit()
alpha   = results.params.iloc[0]  # extract beta_0 (a.k.a. alpha)
beta    = results.params.iloc[1]  # extract beta_1 
p_value = results.pvalues.iloc[0] # significance of alpha
print('Alpha', round(alpha, 4), 'Beta', round(beta, 4), 'p-val', round(p_value, 4))
# Alpha 0.2044 Beta -0.0547 p-val 0.016


#%% (g) ----------------------------------------------------------------------:
'''
Regress the excess returns on each of original 100 assets on both the market 
excess return and the factor-mimicking portfolio for value (computed in d)). 
Remember to include a constant in the regression.

Programming hints:
-	Create a DataFrame called x, using pd.DataFrame() function. Its 1st column
    (call it 'EX') shouldd contains excess market return.
-	Now create a 2nd column (call itc ‘FM’) which contains r_vlaue data. 
    Remember you can create a new column by simply stating new column name and 
    giving it the value(s) such as: df['new'] = 0 
-	Use a for loop to go over each column (i.e. using range(cc))
-	At each iteration, store estimated coefficients and corresponding p-values 
    given the template below
'''
res = pd.DataFrame(np.nan, 
                   index = assets.columns, 
                   columns = ['alpha', 'betaMarket', 'betaValue', 'p_alpha', 
                              'p_betaMarket', 'p_betaValue'])
x = pd.DataFrame(rm - rf, columns = ['EX']) # Market excess return 
x['FM'] = r_value

for ii in range(cc):
    X = sm.add_constant(x)       # Add intercept term 
    y  = assets.iloc[:, ii] - rf # Excess return on asset
    model = sm.OLS(y, X, missing = 'drop')
    results = model.fit()
    # store estimated coefficients
    res.iloc[ii, 0:3] = results.params
    # store significance 
    res.iloc[ii, 3:] = results.pvalues
    
res.iloc[0:3, :]
'''
           alpha  betaMarket  betaValue   p_alpha   p_betaMarket   p_betaValue
Asset1 -0.603415    1.378405   1.273459  0.000915  1.101517e-149  6.558048e-48
Asset2 -0.047317    1.100319   0.939856  0.700791  7.434477e-182  6.362826e-55
Asset3  0.060265    1.086075   1.032536  0.637274  1.793010e-171  3.214032e-60
'''

# save results to csv file
res.to_csv("L7_LAB_g_answers.csv")
